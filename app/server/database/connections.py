import os 
import array
import oracledb
from contextlib import contextmanager
from dotenv import load_dotenv
load_dotenv()

class RAGDBConnection:
    """Singleton for database connection pool and operations."""
    _instance = None
    _initialized = False
    _pool = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        # Avoid re-initialization on subsequent calls
        if RAGDBConnection._initialized:
            return
        RAGDBConnection._initialized = True
        
        self._config_dir = os.getenv("DB_CONFIG_DIR")
        self._user = os.getenv("DB_USER")
        self._password = os.getenv("DB_PASSWORD")
        self._dsn = os.getenv("DB_DSN")
        self._wallet_location = os.getenv("DB_WALLET_PATH")
        self._wallet_password = os.getenv("DB_WALLET_PASSWORD")
        self.table_prefix = "stacks_embeddings"
    
    def _get_pool(self) -> oracledb.ConnectionPool:
        """Get or create the connection pool (lazy initialization)."""
        if RAGDBConnection._pool is None:
            RAGDBConnection._pool = oracledb.create_pool(
                user=self._user,
                password=self._password,
                dsn=self._dsn,
                config_dir=self._config_dir,
                wallet_location=self._wallet_location,
                wallet_password=self._wallet_password,
                min=1,
                max=5,
                increment=1,
            )
        return RAGDBConnection._pool
    
    @contextmanager
    def get_connection(self):
        """Context manager for acquiring a connection from the pool.
        
        Usage:
            with db.get_connection() as conn:
                cols, rows = db.execute_query(conn, sql)
        """
        pool = self._get_pool()
        conn = pool.acquire()
        try:
            yield conn
        finally:
            pool.release(conn)

    def connect_db(self) -> oracledb.Connection:
        try:
            return oracledb.connect(
                user=self._user,
                password=self._password,
                dsn=self._dsn,
                config_dir=self._config_dir,
                wallet_location=self._wallet_location,
                wallet_password=self._wallet_password,
            )
        except oracledb.Error as exc:
            print(f"ERROR: DB connection failed: {exc}")
            raise exc
    
    def disconnect(self, connection: oracledb.Connection):
        connection.close()
    
    def get_cursor(self):
        self.db_connection = self.connect_db()
        self.cursor = self.db_connection.cursor()

    def execute_query(self, conn: oracledb.Connection, sql: str):
        """Execute SQL query and return column names and rows."""
        with conn.cursor() as cur:
            cur.execute(sql)
            return [d[0] for d in cur.description], cur.fetchall()

    def create_table(self):
        """Drop and create embedding table."""
        print("Creating table for embeddings...")

        # Use the prefix to avoid usage of the same table per user
        sql_statements = [
            f"DROP TABLE {self.table_prefix}_embedding PURGE",
            f"""
            CREATE TABLE {self.table_prefix}_embedding (
                id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                text VARCHAR2(4000),
                vec VECTOR,
                source VARCHAR2(100)
            )
            """
        ]

        for stmt in sql_statements:
            try:
                self.cursor.execute(stmt)
            except Exception as e:
                # Ignore if table doesn't exist and create a new one
                print(f"Skipping error: {e}")

    def insert_embedding(self, embeddings, texts, splits):
        for i, emb in enumerate(embeddings):
            chunk_text = texts[i][:3900]  # ensure within VARCHAR2(4000) limit according to table constraint
            metadata_source = f"{splits[i].metadata.get('source', 'pdf-doc')}_start_{splits[i].metadata.get('start_index', 0)}"

            self.cursor.execute(
                f"INSERT INTO {self.table_prefix}_embedding (text, vec, source) VALUES (:1, :2, :3)",
                [chunk_text, array.array("f", emb), metadata_source],
            )
            
        self.db_connection.commit()